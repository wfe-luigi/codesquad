# 1장 웹과 네트워크의 기본에 대해 알아보자
###  HTTP
HyperText Transfer Protocol -> 클라이언트에서 서버까지 일련의 흐름을 결정(규격,약속)  

### TCP/IP
인터넷과 관련된 다양한 프로토콜 집합의 총칭  
TCP/IP는 4계층으로 나누어짐
<br><br>
+ 애플리케이션 계층  

유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정  
FTP,DNS등도 애플리케이션의 한가지. HTTP도 이 계층에 포함!
<br><br>

+ 트랜스포트(전송) 계층  

애플리케이션 계층에 네트워크로 접속되어 있는 2대의컴퓨터 사이의 데이터흐름을 제공

tcp,udp 프로토콜이 존재  
TCP(Transmission Control Protocol)  
UDP(User Date Protocol)
<br><br>

+ 네트워크 계층(인터넷 계층)  

네트워크 상에서 패킷의 이동을 다룸  
패킷 : 전송하는 데이터의 최소 단위
<br><br>

+ 링크 계층(데이터 링크, 네트워크 인터페이스 계층)

네트워크에 접속하는 하드웨어적인 면을 다룸


## TCP/IP 통신
tcp/ip로 통신을 할 때 계층의 순서를 거쳐 상대와 통신  
계층을 거칠때마다 헤더파일이 추가,제거 됨

송신측에서 계층을 내려갈때마다 헤더 추가
수식측에서는 반대로 계층을 올라갈때마다 헤더 제거

## IP
IP(Internet Protocol) -> 네트워크 층에 해당  
개개의 패킷을 상대방에게 전달하는 역할!  

IP주소 : 각 노드에 부여된 주소  
MAC주소 : 각 네트워크 카드에 할당된 고유의 주소(변경불가)

## TCP
TCP(Transfer Control Protocol) -> 트랜스포트(전송)층에 해당  
신뢰성 있는 바이트 스트림을 제공  

대용량의 데이터를 보내기 쉽도록 작게 분해  
-> 상대방에게 전송 후 잘 도착했는지 확인하는 역할!

이때 쓰리웨이 핸드셰이킹이라는 방법 사용

## DNS
DNS(Domain Name System)  
HTTP와 같이 응용계층 시스템에서 도메인 이름과 IP주소이름 확인을 제공 
ex) naver.com -> 125.109.222.141

## URL URI
URI(Uniform Resource Identifiers)  

URL(Uniform Resource Locator)


# 2장 간단한 프로토콜 HTTP
클라이언트 -----> 서버 : 리퀘스트  
클라이언트 <----- 서버 : 리스폰스  

## 리퀘스트 리스폰스 메세지 구성
리퀘스트 메세지 구성  
```
메소드| URI              |프로토콜 버전
GET   /webtoon/list.nhn  HTTP/1.1    //리퀘스트 헤더필드
Host: comic.naver.com                //
Connection: keep-alive               //
...

titleId=648419&weekday=mon //엔티티
```

리스폰스 메세지 구성
```
프로토콜버전 |상태코드 |상태코드 설명
HTTP/1.1    200       OK
Date: Thu, 02 Nov 2017 00:00:00 GMT     //리스폰스 헤더필드
Content-Length: 12632                   //
Content-Type: text/html;charset=UTF-8   //

<html> //바디
...
```

## HTTP 메소드
### GET
리퀘스트 URI로 식별된 리소스를 요구,획득
URL에 담아서 전송

### POST 
엔티티를 전송하기 위해 사용
GET 으로도 엔티티를 전송할 수 있지만,  
URL에 담아서 전송하는 GET과 다르게 HTTP 메세지 바디에 담아서 전송

### PUT
파일을 전송하기 위해서 사용

### HEAD
GET과 같은 기능이지만 메시지 바디는 돌려주지 않음  
URI유효성과 리소스 갱신 시간을 확인하는 목적으로 사용

### DELETE
파일을 삭제하기 위해서 사용
PUT과 반대로 동작

### OPTION
제공하는 있는 메소드의 문의

### TRACE
자신에게 통신을 되돌려주는 루프백(Loop-back)을 발생시킴

### CONNECT
프록시에 터널링 요구


# 3장 HTTP 정보는 HTTP 메세지에 있다
## HTTP 메세지
HTTP에서 교환하는 정보를 HTTP메세지 라고 함  
리퀘스트측 HTTP메세지를 리퀘스트 메세지,  
리스폰스측은 리스폰스 메세지라고 함


## 리퀘스트 메세지와 리스폰스 메세지 구조
### 리퀘스트 메세지 구조
```
메세지헤더{
    리퀘스트 라인
    리퀘스트 헤더 필드
    일반 헤더 필드
    엔티티 헤더 필드
    그외
}
개행문자(CR+LF)
메세지바디
```

### 리스폰스 메세지 구조
```
메시지헤더{
    상태 라인
    리스폰스 헤더 필드
    일반 헤더 필드
    엔티티 헤더 필드
    그외
}
개행문자(CR+LF)
메세지바디
```

리퀘스트 라인  
리퀘스트에 사용하는 메소드와 리퀘스트 URI와 사용하는 HTTP 버전이 포함됨

상태 라인  
리스폰스 결과를 나타내는 상태코드와 설명, 사용하는 HTTP버전이 포함됨

헤더 필드  
리퀘스트와 리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더필드가 포함됨


## 인코딩으로 전송효율 높이기 
### 메시지 바디와 엔티티 바디 차이  
메시지  
HTTP통신의 기본 단위로 옥텟 시퀸스로 구성되고 통신을 통해서 전송

엔티티  
리퀘스트랑 리스폰스의 페이로드로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성됨

### 압축해서 보내는 콘텐츠 코딩
용량이 큼 -> 압축해서 전송 = 콘텐츠 코딩  

주요 콘텐츠 압축
+ gzip
+ compress
+ deflate
+ identity

### 분해해서 보내는 청크 전송 코딩
용량이 큼 -> 전송이 완료되면 보이지 않음 -> 분할 전송  
분한할 하나의 덩어리 = 청크(Chunk)  
=> 청크 전송 코딩

### 여러데이터를 보내는 멀티 파트
메일의 경우 복수의 첨부파일을 전송가능  
->MIME

### 일부분만 받는 레인지 리퀘스트
용량이 큼->다운로드 중에 커넥션이 끊어지면 처음부터 다시전송받아야함  
문제를 어떻게 해결할까? -> 끊어진 곳부터 다시 받기!  
=> 레인지 리퀘스트

### 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션
같은 컨텐츠 이지만 여러페이지  
ex)구글접속 -> 미국에서와 한국에서 페이지 차이가 남!

=> 콘텐츠 네고시에이션  
종류 : 서버 구동형, 에이전트 구동형, 트랜스페어런트 